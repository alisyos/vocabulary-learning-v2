import { DivisionType, GradeType, SubjectType, AreaType, PassageLengthType, QuestionType, TextType } from '@/types';
import { DEFAULT_PROMPTS_V2 } from './promptsV2';

// 구분별 프롬프트 (기존 학년)
const divisionPrompts = {
  '초등학교 중학년(3-4학년)': `초등학교 중학년(3-4학년): 학습자는 짧은 문장 구조와 익숙한 단어를 중심으로 이해할 수 있습니다. 설명은 구체적인 사례와 생활 속 경험에 기반해야 하며, 새로운 개념어에는 간단한 풀이가 필요합니다. 추상적인 개념은 '왜 그럴까?', '무엇이 다를까?'와 같은 질문으로 흥미를 유도하고, 그림을 그리듯 서술해 주세요.`,
  
  '초등학교 고학년(5-6학년)': `초등학교 고학년(5-6학년): 학습자는 다소 긴 문장과 낯선 단어를 접할 수 있으며, 인과관계나 비교 같은 구조를 이해하기 시작합니다. 설명은 실생활 예시에서 출발해 원리나 개념으로 자연스럽게 확장되도록 구성하고, 낱말 풀이도 포함합니다. 경험을 바탕으로 '어떤 일이 일어날까?', '무엇이 원인일까?' 같은 탐구형 문장도 포함해 주세요.`,
  
  '중학생(1-3학년)': `중학생(1-3학년): 학습자는 개념 간의 연결과 간단한 논리 전개를 이해할 수 있으며, 비교·예측·과정 설명에 익숙해집니다. 문장은 다소 길어도 되며, 주제의 흐름을 따라가며 개념의 관계를 파악할 수 있도록 구조화해 주세요. 생소한 개념어는 풀이를 제공하되, 학술적 용어 사용도 일부 가능하며, 사고를 유도하는 질문을 도입부나 전개부에 포함해 주세요.`
};

// 영역별 프롬프트
const areaPrompts = {
  '일반사회': `일반사회: 사회 규범, 규칙과 법, 공동체의 질서, 시민의 권리와 책임 등 사회를 구성하는 제도와 원리를 설명합니다. 초등학생에게는 생활 사례를 통해 제시해 주세요. 중학생에게는 사회 참여와 제도적 구조를 단계적으로 소개할 수 있습니다. 지문 구성 시 제도의 의미와 작동 방식을 생활 속 예시로 연결해 주세요.`,
  
  '지리': `지리: 지형, 기후, 자연환경, 인문환경, 지도 읽기, 지역 간 교류 등 공간과 장소의 특성을 다룹니다. 초등 수준에서는 일상에서 접할 수 있는 자연·인문 환경을 소개하고, 위치나 방향 개념을 단순하게 전달합니다. 중학생 수준에서는 심화된 공간적 사고로 확장할 수 있습니다. 실생활 기반 질문으로 지리적 사고력을 유도하세요.`,
  
  '역사': `역사: 과거 사회의 모습, 주요 인물과 사건, 시대 구분, 변화와 지속성, 문화유산 등을 시간의 흐름 속에서 설명합니다. 초등은 친숙하고 스토리 기반의 접근이 효과적입니다. 중학생은 구조적 설명이 가능합니다. 지문 구성 시 시대적 맥락을 인물이나 사건 중심으로 스토리텔링하세요.`,
  
  '경제': `경제: 필요와 선택, 생산과 소비, 돈과 직업, 시장과 가격, 자원 배분, 경제 활동의 기본 원리를 다룹니다. 초등은 일상적 경제 활동을 중심으로, 상황을 제공합니다. 중학생은 구조적이고 제도적인 요소를 다룹니다. 실생활 사례를 통해 경제적 사고와 의사결정 과정을 경험하도록 지문을 구성해 주세요.`,
  
  '물리': `물리: 힘과 운동, 속력, 마찰, 에너지 전환, 빛과 소리, 전기와 자기 등 자연 현상의 기본 원리를 설명합니다. 초등은 놀이와 생활 도구를 예시로 사용하여 개념을 쉽게 설명합니다. 중학생은 정량적 또는 개념적 분석 중심으로 설명할 수 있습니다. 지문은 탐구 동기를 유도하는 질문으로 시작하세요.`,
  
  '화학': `화학: 물질의 상태(고체, 액체, 기체), 용해와 혼합, 변화(물리·화학), 연소, 산과 염기 등 물질의 성질과 변화를 다룹니다. 초등은 관찰 가능한 생활 속 현상 중심으로 개념을 도입해야 하며, 실험적 탐색을 서술로 표현해 주세요. 중학생은 심화된 개념을 간단한 실생활 반응과 연계하여 설명할 수 있습니다. 지문은 질문형으로 시작하세요.`,
  
  '생물': `생물: 식물과 동물의 구조와 기능, 생명의 특성, 성장과 번식, 감각기관, 생태계 구성과 상호작용을 설명합니다. 초등은 친숙한 생물체를 중심으로 생김새, 먹이, 자라는 과정 등을 관찰 기반으로 설명해야 합니다. 중학생은 정밀한 생명 현상을 구조적으로 다룰 수 있습니다. 호기심 기반으로 시작하여 생물학적 개념을 끌어내세요.`,
  
  '지구과학': `지구과학: 지구의 구조, 날씨와 계절 변화, 화산과 지진, 별과 행성, 지형의 생성, 기후와 환경 문제 등 우주와 지구 시스템을 설명합니다. 초등은 주변 자연 현상 중심으로 구성해야 합니다. 중학생은 심화된 주제를 이해 가능한 수준으로 구조적으로 제시합니다. 지문은 계절·천체 관련 질문으로 시작하세요.`
};

// 지문 길이별 프롬프트 (신규 2개 지문 형식 + 구버전 호환)
const lengthPrompts = {
  // === 새로운 2개 지문 형식 ===
  '2개의 지문 생성. 지문당 300자 내외 - 총 600자': `2개의 지문 생성. 지문당 300자 내외 - 총 600자: 초등학교 중학년(3-4학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 300자 내외로 작성하여 총 600자 정도가 되도록 하세요. 쉬운 어휘와 간단한 문장 구조를 사용하세요.`,
  
  '2개의 지문 생성. 지문당 400자 내외 - 총 800자': `2개의 지문 생성. 지문당 400자 내외 - 총 800자: 초등학교 고학년(5-6학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 400자 내외로 작성하여 총 800자 정도가 되도록 하세요. 다소 복잡한 문장과 전문용어를 적절히 사용할 수 있습니다.`,
  
  '2개의 지문 생성. 지문당 500자 내외 - 총 1,000자': `2개의 지문 생성. 지문당 500자 내외 - 총 1,000자: 중학생(1-3학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 500자 내외로 작성하여 총 1,000자 정도가 되도록 하세요. 논리적 구조와 깊이 있는 내용을 포함할 수 있습니다.`,

  // === 구버전 호환성 (fallback으로 새 형식 반환) ===
  '4-5문장으로 구성한 5-6개 단락': `2개의 지문 생성. 지문당 300자 내외 - 총 600자: 초등학교 중학년(3-4학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 300자 내외로 작성하여 총 600자 정도가 되도록 하세요. 쉬운 어휘와 간단한 문장 구조를 사용하세요.`,
  
  '5-6문장으로 구성한 6개 단락': `2개의 지문 생성. 지문당 400자 내외 - 총 800자: 초등학교 고학년(5-6학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 400자 내외로 작성하여 총 800자 정도가 되도록 하세요. 다소 복잡한 문장과 전문용어를 적절히 사용할 수 있습니다.`,
  
  '1-2문장으로 구성한 10개 단락': `2개의 지문 생성. 지문당 400자 내외 - 총 800자: 초등학교 고학년(5-6학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 400자 내외로 작성하여 총 800자 정도가 되도록 하세요. 다소 복잡한 문장과 전문용어를 적절히 사용할 수 있습니다.`,
  
  '10문장으로 구성한 5개 문단': `2개의 지문 생성. 지문당 500자 내외 - 총 1,000자: 중학생(1-3학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 500자 내외로 작성하여 총 1,000자 정도가 되도록 하세요. 논리적 구조와 깊이 있는 내용을 포함할 수 있습니다.`,
  
  '1-2문장으로 구성한 12개 단락': `2개의 지문 생성. 지문당 500자 내외 - 총 1,000자: 중학생(1-3학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 500자 내외로 작성하여 총 1,000자 정도가 되도록 하세요. 논리적 구조와 깊이 있는 내용을 포함할 수 있습니다.`
};

// 출력 형식 프롬프트 (2개 지문 형식으로 통일)
const outputFormats = {
  '2개의 지문 생성. 지문당 300자 내외 - 총 600자': `{
  "passages": [
    {
      "title": "<하나의 공통 제목>",
      "paragraphs": [
        "<첫 번째 지문 내용 (약 300자)>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)"
      ]
    },
    {
      "title": "<동일한 제목>",
      "paragraphs": [
        "<두 번째 지문 내용 (약 300자)>"
      ],
      "footnote": [
        "용어11: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 자연스러운 예시문장)"
      ]
    }
  ]
}`,

  // === 구버전 호환성 (fallback) ===
  '4-5문장으로 구성한 5-6개 단락': `{
  "passages": [
    {
      "title": "<하나의 공통 제목>",
      "paragraphs": [
        "<첫 번째 지문 내용 (약 300자)>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 용어1을 사용한 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 용어2를 사용한 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 용어3을 사용한 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 용어4를 사용한 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 용어5를 사용한 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 용어6을 사용한 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 용어7을 사용한 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 용어8을 사용한 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 용어9를 사용한 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 용어10을 사용한 자연스러운 예시문장)",
        "용어11: 간단하고 명확한 설명 (예시: 용어11을 사용한 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 용어12를 사용한 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 용어13을 사용한 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 용어14를 사용한 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 용어15를 사용한 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 용어16을 사용한 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 용어17을 사용한 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 용어18을 사용한 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 용어19를 사용한 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 용어20을 사용한 자연스러운 예시문장)",
        "추가용어21: 간단하고 명확한 설명 (예시: 추가용어21을 사용한 자연스러운 예시문장)",
        "추가용어22: 간단하고 명확한 설명 (예시: 추가용어22를 사용한 자연스러운 예시문장)",
        "추가용어23: 간단하고 명확한 설명 (예시: 추가용어23을 사용한 자연스러운 예시문장)",
        "추가용어24: 간단하고 명확한 설명 (예시: 추가용어24를 사용한 자연스러운 예시문장)",
        "추가용어25: 간단하고 명확한 설명 (예시: 추가용어25를 사용한 자연스러운 예시문장)"
      ]
    }
  ]
}`,
  
  '5-6문장으로 구성한 6개 단락': `{
  "passages": [
    {
      "title": "<질문형·흥미유발형 제목>",
      "paragraphs": [
        "<5-6문장으로 구성한 단락1>",
        "<5-6문장으로 구성한 단락2>",
        "<5-6문장으로 구성한 단락3>",
        "<5-6문장으로 구성한 단락4>",
        "<5-6문장으로 구성한 단락5>",
        "<5-6문장으로 구성한 단락6>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 용어1을 사용한 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 용어2를 사용한 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 용어3을 사용한 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 용어4를 사용한 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 용어5를 사용한 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 용어6을 사용한 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 용어7을 사용한 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 용어8을 사용한 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 용어9를 사용한 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 용어10을 사용한 자연스러운 예시문장)",
        "용어11: 간단하고 명확한 설명 (예시: 용어11을 사용한 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 용어12를 사용한 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 용어13을 사용한 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 용어14를 사용한 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 용어15를 사용한 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 용어16을 사용한 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 용어17을 사용한 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 용어18을 사용한 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 용어19를 사용한 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 용어20을 사용한 자연스러운 예시문장)",
        "추가용어21: 간단하고 명확한 설명 (예시: 추가용어21을 사용한 자연스러운 예시문장)",
        "추가용어22: 간단하고 명확한 설명 (예시: 추가용어22를 사용한 자연스러운 예시문장)",
        "추가용어23: 간단하고 명확한 설명 (예시: 추가용어23을 사용한 자연스러운 예시문장)",
        "추가용어24: 간단하고 명확한 설명 (예시: 추가용어24를 사용한 자연스러운 예시문장)",
        "추가용어25: 간단하고 명확한 설명 (예시: 추가용어25을 사용한 자연스러운 예시문장)"
      ]
    }
  ]
}`,
  
  '1-2문장으로 구성한 10개 단락': `{
  "passages": [
    {
      "title": "<질문형·흥미유발형 제목>",
      "paragraphs": [
        "<1-2문장으로 구성한 단락1>",
        "<1-2문장으로 구성한 단락2>",
        "<1-2문장으로 구성한 단락3>",
        "<1-2문장으로 구성한 단락4>",
        "<1-2문장으로 구성한 단락5>",
        "<1-2문장으로 구성한 단락6>",
        "<1-2문장으로 구성한 단락7>",
        "<1-2문장으로 구성한 단락8>",
        "<1-2문장으로 구성한 단락9>",
        "<1-2문장으로 구성한 단락10>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 용어1을 사용한 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 용어2를 사용한 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 용어3을 사용한 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 용어4를 사용한 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 용어5를 사용한 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 용어6을 사용한 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 용어7을 사용한 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 용어8을 사용한 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 용어9를 사용한 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 용어10을 사용한 자연스러운 예시문장)",
        "용어11: 간단하고 명확한 설명 (예시: 용어11을 사용한 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 용어12를 사용한 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 용어13을 사용한 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 용어14를 사용한 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 용어15를 사용한 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 용어16을 사용한 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 용어17을 사용한 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 용어18을 사용한 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 용어19를 사용한 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 용어20을 사용한 자연스러운 예시문장)",
        "추가용어21: 간단하고 명확한 설명 (예시: 추가용어21을 사용한 자연스러운 예시문장)",
        "추가용어22: 간단하고 명확한 설명 (예시: 추가용어22를 사용한 자연스러운 예시문장)",
        "추가용어23: 간단하고 명확한 설명 (예시: 추가용어23을 사용한 자연스러운 예시문장)",
        "추가용어24: 간단하고 명확한 설명 (예시: 추가용어24를 사용한 자연스러운 예시문장)",
        "추가용어25: 간단하고 명확한 설명 (예시: 추가용어25을 사용한 자연스러운 예시문장)"
      ]
    }
  ]
}`,
  
  '10문장 이하로 구성한 5개 단락': `{
  "passages": [
    {
      "title": "<질문형·흥미유발형 제목>",
      "paragraphs": [
        "<10문장 이하로 구성한 단락1>",
        "<10문장 이하로 구성한 단락2>",
        "<10문장 이하로 구성한 단락3>",
        "<10문장 이하로 구성한 단락4>",
        "<10문장 이하로 구성한 단락5>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 용어1을 사용한 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 용어2를 사용한 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 용어3을 사용한 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 용어4를 사용한 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 용어5를 사용한 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 용어6을 사용한 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 용어7을 사용한 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 용어8을 사용한 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 용어9를 사용한 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 용어10을 사용한 자연스러운 예시문장)",
        "용어11: 간단하고 명확한 설명 (예시: 용어11을 사용한 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 용어12를 사용한 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 용어13을 사용한 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 용어14를 사용한 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 용어15를 사용한 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 용어16을 사용한 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 용어17을 사용한 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 용어18을 사용한 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 용어19를 사용한 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 용어20을 사용한 자연스러운 예시문장)",
        "추가용어21: 간단하고 명확한 설명 (예시: 추가용어21을 사용한 자연스러운 예시문장)",
        "추가용어22: 간단하고 명확한 설명 (예시: 추가용어22를 사용한 자연스러운 예시문장)",
        "추가용어23: 간단하고 명확한 설명 (예시: 추가용어23을 사용한 자연스러운 예시문장)",
        "추가용어24: 간단하고 명확한 설명 (예시: 추가용어24를 사용한 자연스러운 예시문장)",
        "추가용어25: 간단하고 명확한 설명 (예시: 추가용어25을 사용한 자연스러운 예시문장)"
      ]
    }
  ]
}`,
  
  '1-2문장으로 구성한 12개 단락': `{
  "passages": [
    {
      "title": "<질문형·흥미유발형 제목>",
      "paragraphs": [
        "<1-2문장으로 구성한 단락1>",
        "<1-2문장으로 구성한 단락2>",
        "<1-2문장으로 구성한 단락3>",
        "<1-2문장으로 구성한 단락4>",
        "<1-2문장으로 구성한 단락5>",
        "<1-2문장으로 구성한 단락6>",
        "<1-2문장으로 구성한 단락7>",
        "<1-2문장으로 구성한 단락8>",
        "<1-2문장으로 구성한 단락9>",
        "<1-2문장으로 구성한 단락10>",
        "<1-2문장으로 구성한 단락11>",
        "<1-2문장으로 구성한 단락12>"
      ],
      "footnote": [
        "용어1: 간단하고 명확한 설명 (예시: 용어1을 사용한 자연스러운 예시문장)",
        "용어2: 간단하고 명확한 설명 (예시: 용어2를 사용한 자연스러운 예시문장)",
        "용어3: 간단하고 명확한 설명 (예시: 용어3을 사용한 자연스러운 예시문장)",
        "용어4: 간단하고 명확한 설명 (예시: 용어4를 사용한 자연스러운 예시문장)",
        "용어5: 간단하고 명확한 설명 (예시: 용어5를 사용한 자연스러운 예시문장)",
        "용어6: 간단하고 명확한 설명 (예시: 용어6을 사용한 자연스러운 예시문장)",
        "용어7: 간단하고 명확한 설명 (예시: 용어7을 사용한 자연스러운 예시문장)",
        "용어8: 간단하고 명확한 설명 (예시: 용어8을 사용한 자연스러운 예시문장)",
        "용어9: 간단하고 명확한 설명 (예시: 용어9를 사용한 자연스러운 예시문장)",
        "용어10: 간단하고 명확한 설명 (예시: 용어10을 사용한 자연스러운 예시문장)",
        "용어11: 간단하고 명확한 설명 (예시: 용어11을 사용한 자연스러운 예시문장)",
        "용어12: 간단하고 명확한 설명 (예시: 용어12를 사용한 자연스러운 예시문장)",
        "용어13: 간단하고 명확한 설명 (예시: 용어13을 사용한 자연스러운 예시문장)",
        "용어14: 간단하고 명확한 설명 (예시: 용어14를 사용한 자연스러운 예시문장)",
        "용어15: 간단하고 명확한 설명 (예시: 용어15를 사용한 자연스러운 예시문장)",
        "용어16: 간단하고 명확한 설명 (예시: 용어16을 사용한 자연스러운 예시문장)",
        "용어17: 간단하고 명확한 설명 (예시: 용어17을 사용한 자연스러운 예시문장)",
        "용어18: 간단하고 명확한 설명 (예시: 용어18을 사용한 자연스러운 예시문장)",
        "용어19: 간단하고 명확한 설명 (예시: 용어19를 사용한 자연스러운 예시문장)",
        "용어20: 간단하고 명확한 설명 (예시: 용어20을 사용한 자연스러운 예시문장)",
        "추가용어21: 간단하고 명확한 설명 (예시: 추가용어21을 사용한 자연스러운 예시문장)",
        "추가용어22: 간단하고 명확한 설명 (예시: 추가용어22를 사용한 자연스러운 예시문장)",
        "추가용어23: 간단하고 명확한 설명 (예시: 추가용어23을 사용한 자연스러운 예시문장)",
        "추가용어24: 간단하고 명확한 설명 (예시: 추가용어24를 사용한 자연스러운 예시문장)",
        "추가용어25: 간단하고 명확한 설명 (예시: 추가용어25을 사용한 자연스러운 예시문장)"
      ]
    }
  ]
}`
};

// 지문 유형별 프롬프트
const textTypePrompts = {
  '생활문': `생활문: 일상생활 속에서 경험하거나 관찰한 내용을 담은 글입니다. 시간 순서대로 일어난 일을 기록하거나, 특정 생활 경험을 통해 깨달은 점을 서술합니다. 친근하고 자연스러운 문체로 작성하며, 학생들이 공감할 수 있는 상황을 활용하세요.`,
  
  '편지글': `편지글: 특정 대상에게 전하는 메시지 형식의 글입니다. 받는 사람을 명시하고, 안부-본론-맺음말의 구조로 구성합니다. 친근하고 정감 있는 어투를 사용하며, 학습 내용을 편지 형식으로 자연스럽게 전달하세요.`,
  
  '기행문': `기행문: 여행이나 견학을 통해 보고 듣고 느낀 것을 기록한 글입니다. 방문 장소의 특징과 의미를 설명하고, 개인적인 감상을 더합니다. 시간이나 동선에 따라 구성하며, 생생한 묘사와 학습 정보를 균형 있게 포함하세요.`,
  
  '논설문': `논설문: 특정 주제에 대한 의견이나 주장을 논리적으로 전개하는 글입니다. 문제 제기-근거 제시-반박-결론의 구조를 가지며, 설득력 있는 근거와 사례를 활용합니다. 학년 수준에 맞는 논리적 사고를 유도하세요.`,
  
  '설명문': `설명문: 사물이나 현상, 개념을 객관적으로 설명하는 글입니다. 정의-특징-예시-활용의 구조로 구성하며, 쉬운 용어와 구체적인 예시를 사용합니다. 복잡한 개념을 단계별로 풀어서 설명하세요.`,
  
  '기사문': `기사문: 사실을 객관적으로 전달하는 뉴스 형식의 글입니다. 육하원칙에 따라 핵심 정보를 먼저 제시하고, 세부 내용을 보충합니다. 간결하고 명확한 문장을 사용하며, 학습 주제와 관련된 시사성 있는 내용을 다루세요.`,
  
  '과학탐구보고서': `과학탐구보고서: 과학적 탐구 과정과 결과를 체계적으로 정리한 글입니다. 탐구 주제-가설-탐구 방법-관찰 결과-결론의 구조로 구성합니다. 과학적 방법론을 따르며, 데이터와 증거를 중심으로 서술하세요.`,
  
  '실험보고서': `실험보고서: 과학 실험의 과정과 결과를 정확히 기록한 글입니다. 실험 목적-재료 및 도구-실험 과정-결과-고찰의 구조로 구성합니다. 단계별 절차를 명확히 하고, 관찰 내용을 객관적으로 기술하세요.`,
  
  '사회현상보고서': `사회현상보고서: 사회 현상을 조사하고 분석한 내용을 담은 글입니다. 현상 소개-원인 분석-영향-해결 방안의 구조로 구성합니다. 통계나 사례를 활용하며, 객관적이고 균형 잡힌 시각을 유지하세요.`
};

// 지문 생성 프롬프트 생성
export function generatePassagePrompt(
  division: DivisionType,
  length: PassageLengthType,
  subject: SubjectType,
  grade: GradeType,
  area: AreaType,
  maintopic: string,
  subtopic: string,
  keyword: string,
  textType?: TextType
): string {
  let prompt = `###지시사항
다음 입력값을 받아 학습 지문(passage)을 생성하십시오. 출력은 하나의 영역으로 구분합니다.
- passage: 입력 조건을 반영해 생성한 지문

모든 지문은 질문형·호기심 유발형 제목을 사용하고, 실생활 예시를 활용해 추상 개념을 설명해야 하며, 임의(random) 로직은 사용하지 않습니다.

###작성절차
1. 키워드 도출
- 구분·과목·학년·영역·지문 길이를 파싱하여 ① 핵심 개념(기초→심화), ② 생활 연계 예시, ③ 학년별 어휘 수준을 도출합니다.
2. 지문(passages) 생성
- 도출한 가이드를 조합해 제목 1개와 본문을 작성합니다.
- 본문은 입력된 지문 길이 가이드라인과 출력 형식 규칙을 정확히 준수합니다.
- **용어 설명 필수 요구사항**: 지문에 등장하는 모든 학습 관련 용어들을 footnote에 포함시켜야 합니다. 최소 20개 이상의 용어를 추출하여 설명하세요.
  * 핵심 개념어와 관련 용어들
  * 지문에 직접 언급된 전문 용어들
  * 학년 수준에 맞는 중요한 어휘들
  * 관련 배경 지식이 필요한 용어들
  * 생활 속에서 사용되는 관련 용어들도 포함
- **용어 설명 형식**: 각 용어에 대해 "용어: 설명 (예시: 예시문장)" 형태로 작성하세요.
  * 설명: 학년 수준에 맞는 간단하고 명확한 설명
  * 예시문장: 해당 용어가 실제로 사용되는 자연스러운 문장
3. 흥미 요소 적용
- 도입부에 실생활 상황·질문을 배치하여 독자의 호기심을 자극합니다.
- 단순 설명문뿐 아니라 비교·예측·원인결과 등 다양한 서술 방식을 활용합니다.
4. 출력 생성
- 아래 [공통 출력 스키마] 형식을 준수한 JSON만 출력하십시오.
- 지정된 키가 없거나 데이터를 찾을 수 없으면 **"-"**로 표기합니다.
- **footnote는 반드시 20개 이상의 용어 설명을 포함해야 하며, 각 용어는 설명과 예시문장을 모두 포함해야 합니다.**

###구분
${divisionPrompts[division]}

###지문 길이
${length}

###과목
${subject}

###학년
${grade}

###영역
${areaPrompts[area] || area}

###대주제
${maintopic}
위 대주제를 중심으로 ${area} 영역의 학습 내용과 연결하여 지문을 구성하세요.

###소주제
${subtopic}
이 소주제를 구체적으로 다루며, 대주제와의 연관성을 명확히 하여 지문을 작성하세요.

###핵심 개념어
${keyword}
이 핵심 개념어들을 지문에 자연스럽게 포함시키고, 학년 수준에 맞게 설명하세요. footnote에는 이 용어들을 포함하여 최소 20개 이상의 관련 용어 해설을 추가하세요.`;

  // 선택적 유형 추가
  if (textType && textType in textTypePrompts) {
    prompt += `

###글의 유형
${textTypePrompts[textType as keyof typeof textTypePrompts]}`;
  }

  prompt += `

###출력형식(JSON)
${outputFormats[length]}`;

  return prompt;
}

// 문제 생성 프롬프트 - 학년별
const questionGradePrompts = {
  '초등학교 중학년(3-4학년)': `초등학교 중학년(3-4학년): 간단한 단어와 짧은 문장 중심으로 문제를 구성합니다. 질문은 사실 확인이나 정의 이해에 초점을 맞추며, 보기/정답/해설은 직관적이고 명확해야 합니다. 어려운 용어나 개념어는 피하고, 지문에서 사용된 표현을 최대한 그대로 활용해 주세요.`,
  
  '초등학교 고학년(5-6학년)': `초등학교 고학년(5-6학년): 개념 간의 관계, 비교, 원인·결과 등 약간 복잡한 사고를 요구할 수 있습니다. 질문은 지문 내용을 바탕으로 추론하거나 판단할 수 있는 형식도 허용됩니다. 해설에는 핵심 개념 간의 연결 관계를 명확히 설명해 주세요.`,
  
  '중학생(1-3학년)': `중학생(1-3학년): 개념을 분석하거나 적용하는 사고력이 반영되어야 하며, 복합적 질문도 가능합니다. 질문은 단순 사실 확인을 넘어, 원리나 맥락 파악을 유도해야 하며, 정답 외 오답 보기도 관련 개념과 혼동될 수 있도록 정교하게 구성해 주세요.`
};

// 문제 유형별 프롬프트
const questionTypePrompts = {
  '객관식': `객관식: 질문에 대한 보기 5개를 생성합니다. 보기는 모두 지문과 관련되어야 하며, 오답도 그럴듯한 근거를 지녀야 합니다. 정답 번호를 명확히 표시하고, 해설은 왜 정답이 맞는지와 왜 다른 보기들이 틀렸는지를 포함합니다.`,
  
  '주관식': `주관식 단답형: 답이 단어 또는 짧은 문장으로 작성 가능한 문제를 생성합니다. 질문은 지문 내 주요 개념, 정의, 원인·결과 등을 묻는 형식이어야 하며, 정답과 해설은 구체적이고 학년 수준에 맞는 설명으로 구성해야 합니다.`
};

// 문제 출력 형식
const questionOutputFormats = {
  '객관식': `{
  "questionType": "객관식",
  "questions": [
    {
      "type": "일반",
      "question": "<질문>",
      "options": ["...", "...", "...", "...", "..."],
      "answer": "<정답 번호>",
      "explanation": "<해설>"
    },
    {
      "type": "보완",
      "question": "<질문>",
      "options": ["...", "...", "...", "...", "..."],
      "answer": "<정답 번호>",
      "explanation": "<해설>"
    },
    {
      "type": "보완",
      "question": "<질문>",
      "options": ["...", "...", "...", "...", "..."],
      "answer": "<정답 번호>",
      "explanation": "<해설>"
    }
  ]
}`,
  
  '주관식': `{
  "questionType": "주관식",
  "questions": [
    {
      "type": "일반",
      "question": "<질문>",
      "answer": "<정답 단어 또는 짧은 문장>",
      "explanation": "<해설>"
    },
    {
      "type": "보완",
      "question": "<질문>",
      "answer": "<정답 단어 또는 짧은 문장>",
      "explanation": "<해설>"
    },
    {
      "type": "보완",
      "question": "<질문>",
      "answer": "<정답 단어 또는 짧은 문장>",
      "explanation": "<해설>"
    }
  ]
}`
};

// 문제 생성 프롬프트 생성
export function generateQuestionPrompt(
  division: DivisionType,
  passage: string,
  questionType: QuestionType
): string {
  return `###지시사항
다음 입력값을 기반으로, 해당 지문 내용을 반영한 **문제 3개**를 생성하십시오.
- 일반 문제 1개와 보완 문제 2개를 생성합니다.
- 일반 문제는 학생이 처음 접하는 문제이며, 보완 문제는 오답 시 학습 강화를 위해 생성하는 구조입니다.
- 구분에 맞는 어휘 수준과 사고 수준을 반영해 난이도를 조절해야 합니다.
- 문제는 반드시 지문 내용 또는 개념을 기반으로 출제되어야 하며, 임의(random) 구성은 금지됩니다.

###지문
${passage}

###구분
${questionGradePrompts[division]}

###문제유형
${questionTypePrompts[questionType]}

###출력형식(JSON)
${questionOutputFormats[questionType]}`;
}

// 어휘 문제 생성 프롬프트 생성
export function generateVocabularyPrompt(
  termName: string,
  termDescription: string,
  passage: string,
  division: string
): string {
  return `###지시사항
주어진 용어에 대한 어휘 문제를 1개 생성하십시오.
- 용어의 의미, 사용법, 맥락을 정확히 이해했는지 평가하는 객관식 문제를 생성합니다.
- 5지선다 형태로 출제하며, 오답 보기도 그럴듯하게 구성해야 합니다.
- 지문의 맥락과 연결하여 문제를 구성하되, 용어 자체의 이해에 초점을 맞춥니다.

###대상 용어
**용어명**: ${termName}
**용어 설명**: ${termDescription || '지문에서 추출된 용어'}

###지문 맥락
${passage}

###구분 (난이도 조절)
${division}

###출력형식(JSON)
다음 JSON 형식으로만 출력하십시오:
{
  "question": "용어의 의미나 사용법을 묻는 질문",
  "options": [
    "정답 선택지",
    "오답 선택지 1", 
    "오답 선택지 2",
    "오답 선택지 3",
    "오답 선택지 4"
  ],
  "answer": "정답 선택지",
  "explanation": "정답인 이유와 오답인 이유를 포함한 해설"
}

###문제 생성 가이드라인
1. **질문 유형**:
   - 용어의 정의를 직접 묻는 문제
   - 용어가 사용된 맥락에서의 의미를 묻는 문제
   - 용어와 관련된 개념이나 예시를 묻는 문제
   - 용어를 다른 상황에 적용하는 문제

2. **선택지 구성**:
   - 정답: 용어의 정확한 의미 또는 올바른 사용법
   - 오답 1: 비슷하지만 미묘하게 다른 의미
   - 오답 2: 관련 있지만 틀린 개념
   - 오답 3: 일반적인 오해나 혼동 가능한 내용
   - 오답 4: 명백히 틀렸지만 그럴듯한 내용

3. **해설 작성**:
   - 정답인 이유를 명확히 설명
   - 주요 오답들이 왜 틀렸는지 간단히 설명
   - 용어의 핵심 개념을 강화하는 내용 포함`;
}

// 종합 문제 유형별 프롬프트 (JSON 출력 형식 포함)
const comprehensiveQuestionPrompts = {
  '정보 확인': `정보 확인: 지문에 직접 제시된 세부 정보를 정확히 파악하고 있는지 확인하는 문제입니다. 사실적 이해와 세부 내용 기억을 평가합니다.

생성 지침:
1. 지문에 명시적으로 언급된 정보 기반
2. 날짜, 숫자, 명칭, 용어 정의 등 구체적 사실 확인
3. 5지선다 객관식으로 구성
4. 정답은 지문에서 직접 확인 가능해야 함

출력 형식:
{
  "type": "정보 확인",
  "questionFormat": "객관식",
  "question": "지문에서 설명한 [구체적 내용]에 대한 설명으로 옳은 것은?",
  "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
  "answer": "3",
  "explanation": "지문의 [해당 부분]에서 확인할 수 있듯이..."
}

주의사항:
- 지문에 직접 나타난 정보만 활용
- 추론이나 해석이 필요 없는 명확한 문제
- 오답도 지문 내용과 관련되게 구성`,

  '주제 파악': `주제 파악: 지문의 중심 주제나 핵심 메시지를 파악하는 문제입니다. 글 전체를 관통하는 주요 아이디어를 이해하고 있는지 평가합니다.

생성 지침:
1. 지문의 전체적인 흐름과 핵심 메시지 파악
2. 주제문, 결론, 핵심 아이디어를 중심으로 요약
3. 5개의 선택지 중 1개만이 정확한 요약이 되도록 구성
4. 오답은 부분적 내용, 과도한 일반화, 잘못된 해석 등으로 구성

출력 형식:
{
  "type": "핵심 내용 요약",
  "questionFormat": "객관식",
  "question": "다음 글의 핵심 내용을 가장 잘 요약한 것은?",
  "options": [
    "정답: 지문의 주제와 핵심 내용을 정확히 반영한 요약문",
    "오답1: 부분적 내용만 포함한 요약문",
    "오답2: 과도하게 일반화된 요약문",
    "오답3: 핵심을 놓친 요약문",
    "오답4: 잘못 해석된 요약문"
  ],
  "answer": "1",
  "explanation": "정답 선택지가 지문의 어느 부분을 반영하는지 구체적으로 설명"
}

주의사항:
- 각 선택지는 150-200자 내외로 구성
- 정답은 지문의 핵심을 모두 포함해야 함
- 오답들은 그럴듯하지만 명확한 차이점이 있어야 함`,

  '자료해석': `자료해석: 지문에 제시된 정보나 자료를 분석하고 해석하는 문제입니다. 표, 그래프, 수치 데이터 또는 텍스트 내 비교/대조 정보를 올바르게 이해하고 있는지 평가합니다.

생성 지침:
1. 지문에 포함된 구체적인 수치, 데이터, 비교 내용 활용
2. 데이터의 경향, 변화, 비교, 특징 등을 묻는 문제 구성
3. 정확한 수치 해석이나 논리적 분석력을 평가
4. 자료가 없는 경우, 지문의 비교/대조 내용을 분석 대상으로 활용

출력 형식:
{
  "type": "자료해석",
  "questionFormat": "객관식",
  "question": "지문의 자료(또는 내용)를 분석한 결과로 옳은 것은?",
  "options": [
    "정답: 지문의 자료를 정확히 분석한 내용",
    "오답1: 수치를 잘못 해석한 내용",
    "오답2: 경향을 반대로 분석한 내용",
    "오답3: 일부 데이터만 고려한 내용",
    "오답4: 지문에 없는 추론을 포함한 내용"
  ],
  "answer": "1",
  "explanation": "자료의 어느 부분을 근거로 해당 분석이 맞는지 구체적 수치와 함께 설명"
}

분석 유형 예시:
- 수치 비교: "A가 B보다 [구체적 수치]만큼 높다/낮다"
- 경향 분석: "[특정 기간] 동안 [지속적 증가/감소/변화없음] 경향을 보인다"
- 비율 분석: "전체에서 [특정 부분]이 [구체적 비율]을 차지한다"
- 변화 분석: "[이전 대비] [구체적 변화량/변화율]의 변화가 있다"

주의사항:
- 지문에 명시되지 않은 추론은 지양
- 구체적 수치나 사실 기반 분석 우선
- 정답은 지문의 자료에서 직접 확인 가능해야 함`,

  '추론': `추론: 지문의 내용을 바탕으로 논리적 추론이나 적용을 요구하는 문제입니다. 직접 언급되지 않았지만 지문의 정보로부터 유추할 수 있는 내용을 평가합니다.

생성 지침:
1. 지문의 내용을 바탕으로 논리적으로 추론 가능한 내용
2. 원인-결과, 비교-대조, 일반화-적용 등의 사고력 평가
3. 지문의 원리나 개념을 새로운 상황에 적용하는 문제
4. 5지선다 객관식으로 구성

출력 형식:
{
  "type": "추론",
  "questionFormat": "객관식",
  "question": "지문의 내용을 바탕으로 추론할 때, 가장 적절한 것은?",
  "options": [
    "정답: 논리적으로 타당한 추론",
    "오답1: 과도한 일반화",
    "오답2: 논리적 비약",
    "오답3: 부분적으로만 맞는 추론",
    "오답4: 근거가 부족한 추론"
  ],
  "answer": "1",
  "explanation": "지문의 어떤 내용을 근거로 해당 추론이 가능한지 논리적 과정 설명"
}

추론 유형 예시:
- 원인 추론: "이러한 결과가 나타난 이유는..."
- 결과 예측: "이 상황이 지속된다면..."
- 적용: "같은 원리를 다른 상황에 적용하면..."
- 비교 추론: "A와 B의 관계로 볼 때..."

주의사항:
- 지문에서 충분한 근거를 찾을 수 있는 추론이어야 함
- 과도한 비약이나 상상은 지양
- 논리적 타당성이 중요`
};

// 종합 문제 출력 형식
const comprehensiveOutputFormats = {
  '정보 확인': `{
  "questions": [
    {
      "id": "comp_info_1",
      "type": "정보 확인",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답 번호 (1-5)",
      "explanation": "해설"
    }
  ]
}`,

  '주제 파악': `{
  "questions": [
    {
      "id": "comp_theme_1",
      "type": "주제 파악",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답 번호 (1-5)",
      "explanation": "해설"
    }
  ]
}`,

  '자료해석': `{
  "questions": [
    {
      "id": "comp_data_1",
      "type": "자료해석",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답 번호 (1-5)",
      "explanation": "해설"
    }
  ]
}`,

  '추론': `{
  "questions": [
    {
      "id": "comp_infer_1",
      "type": "추론",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답 번호 (1-5)",
      "explanation": "해설"
    }
  ]
}`,

  // 기존 형식은 하위 호환성을 위해 유지
  '단답형': `{
  "questions": [
    {
      "id": "comp_short_1",
      "type": "단답형",
      "question": "질문 내용",
      "answer": "정답",
      "answerInitials": "초성 힌트 (예: ㅈㄹㅎㅁ)",
      "explanation": "해설"
    },
    {
      "id": "comp_short_2", 
      "type": "단답형",
      "question": "질문 내용",
      "answer": "정답",
      "answerInitials": "초성 힌트 (예: ㅈㄹㅎㅁ)", 
      "explanation": "해설"
    },
    {
      "id": "comp_short_3",
      "type": "단답형", 
      "question": "질문 내용",
      "answer": "정답",
      "answerInitials": "초성 힌트 (예: ㅈㄹㅎㅁ)",
      "explanation": "해설"
    }
  ]
}`,

  '핵심 내용 요약': `{
  "questions": [
    {
      "id": "comp_summary_1",
      "type": "핵심 내용 요약",
      "question": "다음 중 지문의 내용을 가장 잘 요약한 것은?",
      "options": [
        "올바른 요약문",
        "부분적으로만 맞는 요약문",
        "과장된 요약문", 
        "핵심을 놓친 요약문",
        "잘못된 요약문"
      ],
      "answer": "올바른 요약문",
      "explanation": "해설"
    },
    {
      "id": "comp_summary_2",
      "type": "핵심 내용 요약",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답",
      "explanation": "해설"
    },
    {
      "id": "comp_summary_3", 
      "type": "핵심 내용 요약",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답",
      "explanation": "해설"
    }
  ]
}`,

  '핵심문장 찾기': `{
  "questions": [
    {
      "id": "comp_keyword_1",
      "type": "핵심문장 찾기",
      "question": "다음 중 지문의 핵심을 가장 잘 나타내는 문장은?",
      "options": [
        "핵심 문장",
        "부차적 문장1",
        "부차적 문장2", 
        "세부사항 문장",
        "관련 없는 문장"
      ],
      "answer": "핵심 문장",
      "explanation": "해설"
    },
    {
      "id": "comp_keyword_2",
      "type": "핵심문장 찾기", 
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답",
      "explanation": "해설"
    },
    {
      "id": "comp_keyword_3",
      "type": "핵심문장 찾기",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"], 
      "answer": "정답",
      "explanation": "해설"
    }
  ]
}`,

  'OX문제': `{
  "questions": [
    {
      "id": "comp_ox_1",
      "type": "OX문제",
      "question": "OX 문제 내용",
      "options": ["○ (맞다)", "X (틀리다)"],
      "answer": "○ (맞다)",
      "explanation": "해설 내용"
    },
    {
      "id": "comp_ox_2",
      "type": "OX문제",
      "question": "질문 내용",
      "options": ["○ (맞다)", "X (틀리다)"],
      "answer": "X (틀리다)",
      "explanation": "해설"
    },
    {
      "id": "comp_ox_3",
      "type": "OX문제",
      "question": "질문 내용",
      "options": ["○ (맞다)", "X (틀리다)"],
      "answer": "○ (맞다)",
      "explanation": "해설"
    }
  ]
}`,

  '자료분석하기': `{
  "questions": [
    {
      "id": "comp_data_1",
      "type": "자료분석하기",
      "question": "자료 분석 문제 내용",
      "options": ["분석 결과 1", "분석 결과 2", "분석 결과 3", "분석 결과 4", "분석 결과 5"],
      "answer": "분석 결과 1",
      "explanation": "해설 내용"
    },
    {
      "id": "comp_data_2",
      "type": "자료분석하기",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답",
      "explanation": "해설"
    },
    {
      "id": "comp_data_3",
      "type": "자료분석하기",
      "question": "질문 내용",
      "options": ["선택지1", "선택지2", "선택지3", "선택지4", "선택지5"],
      "answer": "정답",
      "explanation": "해설"
    }
  ]
}`
};

// 종합 문제 생성 프롬프트 생성
export function generateComprehensivePrompt(
  questionType: string, // '단답형', '문단별 순서 맞추기', etc.
  passage: string,
  division: string,
  questionCount: number = 3
): string {
  return `###지시사항
주어진 지문을 바탕으로 **${questionType}** 유형의 문제 ${questionCount}개를 생성하십시오.
- 지문의 전체적인 이해와 핵심 내용 파악을 평가하는 문제를 생성합니다.
- 각 문제는 서로 다른 관점이나 내용을 다뤄야 합니다.
- 지문에 직접 언급된 내용이나 논리적으로 추론 가능한 내용만을 바탕으로 출제합니다.

###지문
${passage}

###구분 (난이도 조절)  
${division}

###문제 유형 가이드라인
${comprehensiveQuestionPrompts[questionType as keyof typeof comprehensiveQuestionPrompts]}

###출력형식(JSON)
${comprehensiveOutputFormats[questionType as keyof typeof comprehensiveOutputFormats]}

###주의사항
- 반드시 위의 JSON 형식을 정확히 준수하십시오.
- 정확히 ${questionCount}개의 문제를 생성하십시오.
- 각 문제는 서로 다른 내용이나 관점을 다뤄야 합니다.
- 정답과 해설은 지문에 명확히 근거해야 합니다.
- 객관식 문제의 오답 선택지도 그럴듯하게 구성하십시오.`;
}

// ============================================================================
// 프롬프트 관리 시스템을 위한 기본 데이터 추출 함수
// ============================================================================

export function getDefaultPrompts() {
  // promptsV2의 DEFAULT_PROMPTS_V2를 반환
  console.log('🔍 getDefaultPrompts called');
  
  // 어절 순서 맞추기 프롬프트를 직접 수정된 버전으로 강제 교체
  const prompts = [...DEFAULT_PROMPTS_V2];
  const orderPromptIndex = prompts.findIndex(p => p.promptId === 'paragraph-type-order');
  
  if (orderPromptIndex !== -1) {
    // 기존 프롬프트를 새로운 주관식 버전으로 교체
    prompts[orderPromptIndex] = {
      ...prompts[orderPromptIndex],
      promptText: `어절 순서 맞추기: 문단의 핵심 문장을 어절 단위로 섞어 놓고, 올바른 순서로 배열하는 문제입니다. 문법적으로 자연스럽고 의미가 통하는 순서를 찾도록 합니다.

중요: 
- 어절들을 개별적으로 배열로 제공하세요
- 정답은 완전한 문장으로 제공하세요

출력 형식:
{
  "type": "어절 순서 맞추기",
  "question": "다음 어절들을 올바른 순서로 배열하여 문장을 완성하세요.",
  "wordSegments": ["어절1", "어절2", "어절3", "어절4", "어절5"],
  "answer": "올바르게 배열된 완전한 문장",
  "explanation": "정답 해설 (왜 이 순서가 맞는지 설명)"
}`
    };
    console.log('✅ 어절 순서 맞추기 프롬프트를 주관식 버전으로 강제 교체했습니다');
  }
  
  const orderPrompt = prompts.find(p => p.promptId === 'paragraph-type-order');
  console.log('🔍 교체된 어절 순서 맞추기 프롬프트 확인:', {
    found: !!orderPrompt,
    promptId: orderPrompt?.promptId,
    name: orderPrompt?.name,
    textPreview: orderPrompt?.promptText?.substring(0, 100) + '...'
  });
  
  return prompts;
  
  // 폴백: 기존 하드코딩된 프롬프트 생성
  const defaultPrompts = [];
  let promptCounter = 1; // 고유 ID 생성용 카운터

  // 0. 전체 지문생성 시스템 프롬프트
  const fullPassagePrompt = `###지시사항
다음 입력값을 받아 학습 지문(passage)을 생성하십시오. 출력은 하나의 영역으로 구분합니다.
- passage: 입력 조건을 반영해 생성한 지문

모든 지문은 질문형·호기심 유발형 제목을 사용하고, 실생활 예시를 활용해 추상 개념을 설명해야 하며, 임의(random) 로직은 사용하지 않습니다.

###작성절차
1. 키워드 도출
- 구분·과목·학년·영역·지문 길이를 파싱하여 ① 핵심 개념(기초→심화), ② 생활 연계 예시, ③ 학년별 어휘 수준을 도출합니다.
2. 지문(passages) 생성
- 도출한 가이드를 조합해 제목 1개와 본문을 작성합니다.
- 본문은 입력된 지문 길이 가이드라인과 출력 형식 규칙을 정확히 준수합니다.
- **용어 설명 필수 요구사항**: 지문에 등장하는 모든 학습 관련 용어들을 footnote에 포함시켜야 합니다. 최소 20개 이상의 용어를 추출하여 설명하세요.
  * 핵심 개념어와 관련 용어들
  * 지문에 직접 언급된 전문 용어들
  * 학년 수준에 맞는 중요한 어휘들
  * 관련 배경 지식이 필요한 용어들
  * 생활 속에서 사용되는 관련 용어들도 포함
- **용어 설명 형식**: 각 용어에 대해 "용어: 설명 (예시: 예시문장)" 형태로 작성하세요.
  * 설명: 학년 수준에 맞는 간단하고 명확한 설명
  * 예시문장: 해당 용어가 실제로 사용되는 자연스러운 문장
3. 흥미 요소 적용
- 도입부에 실생활 상황·질문을 배치하여 독자의 호기심을 자극합니다.
- 단순 설명문뿐 아니라 비교·예측·원인결과 등 다양한 서술 방식을 활용합니다.
4. 출력 생성
- 아래 [공통 출력 스키마] 형식을 준수한 JSON만 출력하십시오.
- 지정된 키가 없거나 데이터를 찾을 수 없으면 **"-"**로 표기합니다.
- **footnote는 반드시 20개 이상의 용어 설명을 포함해야 하며, 각 용어는 설명과 예시문장을 모두 포함해야 합니다.**

###구분
{division_prompt}

###지문 길이
{length_prompt}

###과목
{subject}

###학년
{grade}

###영역
{area_prompt}

###대주제
{maintopic}
위 대주제를 중심으로 {area} 영역의 학습 내용과 연결하여 지문을 구성하세요.

###소주제
{subtopic}
이 소주제를 구체적으로 다루며, 대주제와의 연관성을 명확히 하여 지문을 작성하세요.

###핵심 개념어
{keyword}
이 핵심 개념어들을 지문에 자연스럽게 포함시키고, 학년 수준에 맞게 설명하세요. footnote에는 이 용어들을 포함하여 최소 20개 이상의 관련 용어 해설을 추가하세요.

###글의 유형 (선택사항)
{texttype_prompt}

###출력형식(JSON)
{output_format}

※ 위의 {변수명} 부분은 실제 사용 시 동적으로 치환됩니다.`;

  defaultPrompts.push({
    promptId: `prompt_${promptCounter++}`,
    category: 'passage' as const,
    subCategory: 'system' as const,
    name: '전체 지문생성 시스템 프롬프트',
    key: 'fullSystemPrompt',
    promptText: fullPassagePrompt,
    description: '지문 생성에 사용되는 완전한 시스템 프롬프트 템플릿'
  });

  // 0-1. 전체 어휘 문제 생성 시스템 프롬프트
  const fullVocabularyPrompt = `###지시사항
주어진 용어에 대한 어휘 문제를 1개 생성하십시오.
- 용어의 의미, 사용법, 맥락을 정확히 이해했는지 평가하는 객관식 문제를 생성합니다.
- 5지선다 형태로 출제하며, 오답 보기도 그럴듯하게 구성해야 합니다.
- 지문의 맥락과 연결하여 문제를 구성하되, 용어 자체의 이해에 초점을 맞춥니다.

###대상 용어
**용어명**: {term_name}
**용어 설명**: {term_description}

###지문 맥락
{passage}

###구분 (난이도 조절)
{division_prompt}

###출력형식(JSON)
다음 JSON 형식으로만 출력하십시오:
{
  "question": "용어의 의미나 사용법을 묻는 질문",
  "options": [
    "정답 선택지",
    "오답 선택지 1", 
    "오답 선택지 2",
    "오답 선택지 3",
    "오답 선택지 4"
  ],
  "answer": "정답 선택지",
  "explanation": "정답인 이유와 오답인 이유를 포함한 해설"
}

###문제 생성 가이드라인
1. **질문 유형**:
   - 용어의 정의를 직접 묻는 문제
   - 용어가 사용된 맥락에서의 의미를 묻는 문제
   - 용어와 관련된 개념이나 예시를 묻는 문제
   - 용어를 다른 상황에 적용하는 문제

2. **선택지 구성**:
   - 정답: 용어의 정확한 의미 또는 올바른 사용법
   - 오답 1: 비슷하지만 미묘하게 다른 의미
   - 오답 2: 관련 있지만 틀린 개념
   - 오답 3: 일반적인 오해나 혼동 가능한 내용
   - 오답 4: 명백히 틀렸지만 그럴듯한 내용

3. **해설 작성**:
   - 정답인 이유를 명확히 설명
   - 주요 오답들이 왜 틀렸는지 간단히 설명
   - 용어의 핵심 개념을 강화하는 내용 포함

※ 위의 {변수명} 부분은 실제 사용 시 동적으로 치환됩니다.`;

  defaultPrompts.push({
    promptId: `prompt_${promptCounter++}`,
    category: 'vocabulary' as const,
    subCategory: 'system' as const,
    name: '전체 어휘 문제 생성 시스템 프롬프트',
    key: 'fullSystemPrompt',
    promptText: fullVocabularyPrompt,
    description: '어휘 문제 생성에 사용되는 완전한 시스템 프롬프트 템플릿'
  });

  // 0-2. 전체 종합 문제 생성 시스템 프롬프트
  const fullComprehensivePrompt = `###지시사항
주어진 지문을 바탕으로 **{question_type}** 유형의 문제 {question_count}개를 생성하십시오.
- 지문의 전체적인 이해와 핵심 내용 파악을 평가하는 문제를 생성합니다.
- 각 문제는 서로 다른 관점이나 내용을 다뤄야 합니다.
- 지문에 직접 언급된 내용이나 논리적으로 추론 가능한 내용만을 바탕으로 출제합니다.

###지문
{passage}

###구분 (난이도 조절)  
{division_prompt}

###문제 유형 가이드라인
{question_type_prompt}

###출력형식(JSON)
{output_format}

###주의사항
- 반드시 위의 JSON 형식을 정확히 준수하십시오.
- 각 문제는 서로 다른 내용이나 관점을 다뤄야 합니다.
- 정답과 해설은 지문에 명확히 근거해야 합니다.
- 객관식 문제의 오답 선택지도 그럴듯하게 구성하십시오.

※ 위의 {변수명} 부분은 실제 사용 시 동적으로 치환됩니다.`;

  defaultPrompts.push({
    promptId: `prompt_${promptCounter++}`,
    category: 'comprehensive' as const,
    subCategory: 'system' as const,
    name: '전체 종합 문제 생성 시스템 프롬프트',
    key: 'fullSystemPrompt',
    promptText: fullComprehensivePrompt,
    description: '종합 문제 생성에 사용되는 완전한 시스템 프롬프트 템플릿'
  });

  // 1. 구분별 프롬프트 (Division) - 별도 카테고리로 분리
  Object.entries(divisionPrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'division' as const,
      subCategory: 'divisionLevel' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key}에 대한 학습 수준별 프롬프트`
    });
  });

  // 2. 영역별 프롬프트 (Area) - 별도 카테고리로 분리
  Object.entries(areaPrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'area' as const,
      subCategory: 'areaContent' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 영역에 대한 지문 생성 가이드라인`
    });
  });

  // 3. 지문 길이별 프롬프트 (Length Guidelines)
  Object.entries(lengthPrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'passage' as const,
      subCategory: 'lengthGuideline' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 구성의 지문 생성 가이드라인`
    });
  });

  // 4. 출력 형식별 프롬프트 (Output Format)
  Object.entries(outputFormats).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'passage' as const,
      subCategory: 'outputFormat' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 형식의 지문 JSON 출력 구조`
    });
  });

  // 5. 지문 유형별 프롬프트 (Text Type)
  Object.entries(textTypePrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'passage' as const,
      subCategory: 'textType' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 유형의 지문 생성 가이드라인`
    });
  });

  // 5. 문제 생성 - 학년별 프롬프트 (Question Grade)
  Object.entries(questionGradePrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'vocabulary' as const,
      subCategory: 'questionGrade' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key}을 위한 문제 생성 가이드라인`
    });
  });

  // 6. 문제 유형별 프롬프트 (Question Type)
  Object.entries(questionTypePrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'vocabulary' as const,
      subCategory: 'questionType' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 문제 생성 가이드라인`
    });
  });

  // 7. 문제 출력 형식별 프롬프트 (Question Output Format)
  Object.entries(questionOutputFormats).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'vocabulary' as const,
      subCategory: 'outputFormat' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 문제의 출력 형식`
    });
  });

  // 8. 종합 문제 유형별 프롬프트 (Comprehensive Question Type)
  Object.entries(comprehensiveQuestionPrompts).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'comprehensive' as const,
      subCategory: 'comprehensiveType' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 유형의 종합 문제 생성 가이드라인`
    });
  });

  // 9. 종합 문제 출력 형식별 프롬프트 (Comprehensive Output Format)
  Object.entries(comprehensiveOutputFormats).forEach(([key, value]) => {
    defaultPrompts.push({
      promptId: `prompt_${promptCounter++}`,
      category: 'comprehensive' as const,
      subCategory: 'outputFormat' as const,
      name: key,
      key: key,
      promptText: value,
      description: `${key} 종합 문제의 출력 형식`
    });
  });

  // 10. 어휘 문제 기본 프롬프트
  const vocabularyBasePrompt = `###지시사항
주어진 용어에 대한 어휘 문제를 1개 생성하십시오.
- 용어의 의미, 사용법, 맥락을 정확히 이해했는지 평가하는 객관식 문제를 생성합니다.
- 5지선다 형태로 출제하며, 오답 보기도 그럴듯하게 구성해야 합니다.
- 지문의 맥락과 연결하여 문제를 구성하되, 용어 자체의 이해에 초점을 맞춥니다.`;

  defaultPrompts.push({
    promptId: `prompt_${promptCounter++}`,
    category: 'vocabulary' as const,
    subCategory: 'vocabularyBase' as const,
    name: '어휘 문제 기본 프롬프트',
    key: 'vocabularyBase',
    promptText: vocabularyBasePrompt,
    description: '어휘 문제 생성을 위한 기본 프롬프트'
  });

  return defaultPrompts;
}

// ============================================================================
// DB에서 프롬프트를 조회하는 새로운 함수들
// ============================================================================

// 메모리 캐시를 저장할 전역 변수
const promptCache = new Map<string, { text: string, timestamp: number }>();
const CACHE_DURATION = 5 * 60 * 1000; // 5분

// 영역명 한글 -> 영어 키 매핑
export function getAreaKey(areaName: string): string {
  const areaKeyMap: { [key: string]: string } = {
    '지리': 'geography',
    '일반사회': 'social', 
    '역사': 'history',
    '경제': 'economy',
    '정치': 'politics',
    '화학': 'chemistry',
    '물리': 'physics',
    '생물': 'biology',
    '생명': 'biology', // 생물과 생명은 같은 키 사용
    '지구과학': 'earth',
    '과학탐구': 'science_inquiry'
  };
  return areaKeyMap[areaName] || areaName;
}

// 영역명 한글 -> 서브카테고리 매핑
export function getAreaSubCategory(areaName: string): string {
  const areaSubCategoryMap: { [key: string]: string } = {
    '지리': 'areaGeography',
    '일반사회': 'areaSocial', 
    '역사': 'areaHistory',
    '경제': 'areaEconomy',
    '정치': 'areaPolitics',
    '화학': 'areaChemistry',
    '물리': 'areaPhysics',
    '생물': 'areaBiology',
    '생명': 'areaBiology', // 생물과 생명은 같은 서브카테고리 사용
    '지구과학': 'areaEarth',
    '과학탐구': 'areaScienceInquiry'
  };
  return areaSubCategoryMap[areaName] || 'areaContent';
}

// 구분명 한글 -> 영어 키 매핑
export function getDivisionKey(divisionName: string): string {
  const divisionKeyMap: { [key: string]: string } = {
    '중학생(1-3학년)': 'middle',
    '초등학교 고학년(5-6학년)': 'elem_high',
    '초등학교 중학년(3-4학년)': 'elem_mid'
  };
  return divisionKeyMap[divisionName] || divisionName;
}

// 구분명 한글 -> 서브카테고리 매핑
export function getDivisionSubCategory(divisionName: string): string {
  const divisionSubCategoryMap: { [key: string]: string } = {
    '중학생(1-3학년)': 'divisionMiddle',
    '초등학교 고학년(5-6학년)': 'divisionElemHigh',
    '초등학교 중학년(3-4학년)': 'divisionElemMid'
  };
  return divisionSubCategoryMap[divisionName] || 'divisionLevel';
}

// 과목명 한글 -> 영어 키 매핑
export function getSubjectKey(subjectName: string): string {
  const subjectKeyMap: { [key: string]: string } = {
    '과학': 'science',
    '사회': 'social'
  };
  return subjectKeyMap[subjectName] || subjectName;
}

// 과목명 한글 -> 서브카테고리 매핑
export function getSubjectSubCategory(subjectName: string): string {
  const subjectSubCategoryMap: { [key: string]: string } = {
    '과학': 'subjectScience',
    '사회': 'subjectSocial'
  };
  return subjectSubCategoryMap[subjectName] || 'subjectContent';
}

// 글의 유형명 한글 -> 영어 키 매핑
export function getTextTypeKey(textTypeName: string): string {
  const textTypeKeyMap: { [key: string]: string } = {
    '생활문': 'type_life',
    '편지글': 'type_letter',
    '기행문': 'type_travel',
    '논설문': 'type_essay',
    '설명문': 'type_explanation',
    '기사문': 'type_news',
    '과학탐구보고서': 'type_science_inquiry',
    '실험보고서': 'type_experiment',
    '사회현상보고서': 'type_social_report'
  };
  return textTypeKeyMap[textTypeName] || textTypeName;
}

// 기본 텍스트 유형 프롬프트 반환 함수
function getDefaultTextTypePrompt(textType: string): string {
  const textTypePrompts: { [key: string]: string } = {
    '생활문': `생활문: 일상생활 속에서 경험하거나 관찰한 내용을 담은 글입니다. 시간 순서대로 일어난 일을 기록하거나, 특정 생활 경험을 통해 깨달은 점을 서술합니다. 친근하고 자연스러운 문체로 작성하며, 학생들이 공감할 수 있는 상황을 활용하세요.`,
    
    '편지글': `편지글: 특정 대상에게 전하는 메시지 형식의 글입니다. 받는 사람을 명시하고, 안부-본론-맺음말의 구조로 구성합니다. 친근하고 정감 있는 어투를 사용하며, 학습 내용을 편지 형식으로 자연스럽게 전달하세요.`,
    
    '기행문': `기행문: 여행이나 견학을 통해 보고 듣고 느낀 것을 기록한 글입니다. 방문 장소의 특징과 의미를 설명하고, 개인적인 감상을 더합니다. 시간이나 동선에 따라 구성하며, 생생한 묘사와 학습 정보를 균형 있게 포함하세요.`,
    
    '논설문': `논설문: 특정 주제에 대한 의견이나 주장을 논리적으로 전개하는 글입니다. 문제 제기-근거 제시-반박-결론의 구조를 가지며, 설득력 있는 근거와 사례를 활용합니다. 학년 수준에 맞는 논리적 사고를 유도하세요.`,
    
    '설명문': `설명문: 사물이나 현상, 개념을 객관적으로 설명하는 글입니다. 정의-특징-예시-활용의 구조로 구성하며, 쉬운 용어와 구체적인 예시를 사용합니다. 복잡한 개념을 단계별로 풀어서 설명하세요.`,
    
    '기사문': `기사문: 사실을 객관적으로 전달하는 뉴스 형식의 글입니다. 육하원칙에 따라 핵심 정보를 먼저 제시하고, 세부 내용을 보충합니다. 간결하고 명확한 문장을 사용하며, 학습 주제와 관련된 시사성 있는 내용을 다루세요.`,
    
    '과학탐구보고서': `과학탐구보고서: 과학적 탐구 과정과 결과를 체계적으로 정리한 글입니다. 탐구 주제-가설-탐구 방법-관찰 결과-결론의 구조로 구성합니다. 과학적 방법론을 따르며, 데이터와 증거를 중심으로 서술하세요.`,
    
    '실험보고서': `실험보고서: 과학 실험의 과정과 결과를 정확히 기록한 글입니다. 실험 목적-재료 및 도구-실험 과정-결과-고찰의 구조로 구성합니다. 단계별 절차를 명확히 하고, 관찰 내용을 객관적으로 기술하세요.`,
    
    '사회현상보고서': `사회현상보고서: 사회 현상을 조사하고 분석한 내용을 담은 글입니다. 현상 소개-원인 분석-영향-해결 방안의 구조로 구성합니다. 통계나 사례를 활용하며, 객관적이고 균형 잡힌 시각을 유지하세요.`
  };
  
  return textTypePrompts[textType] || '';
}

// 종합 문제 유형명 한글 -> DB 키 매핑
export function getComprehensiveTypeKey(typeName: string): string {
  const typeKeyMap: { [key: string]: string } = {
    // 새로운 4가지 유형: DB에 한글 키로 저장됨
    '정보 확인': '정보 확인',
    '주제 파악': '주제 파악',
    '자료해석': '자료해석',
    '추론': '추론'
  };
  return typeKeyMap[typeName] || typeName;
}

// Supabase에서 프롬프트를 조회하여 기존 방식으로 사용할 수 있도록 하는 함수
export async function getPromptFromDB(category: string, subCategory: string, key: string): Promise<string> {
  const cacheKey = `${category}/${subCategory}/${key}`;
  
  // 캐시 확인
  const cached = promptCache.get(cacheKey);
  if (cached && Date.now() - cached.timestamp < CACHE_DURATION) {
    console.log(`캐시에서 프롬프트 사용: ${cacheKey}`);
    return cached.text;
  }
  
  try {
    console.log(`🔍 DB 조회 시도: ${category}/${subCategory}/${key}`);
    const { db } = await import('./supabase');
    const prompt = await db.getPromptByKey(category, subCategory, key);
    
    if (prompt && prompt.promptText) {
      console.log(`✅ DB 조회 성공: ${cacheKey} (${prompt.promptText.length} chars)`);
      // 캐시에 저장
      promptCache.set(cacheKey, { text: prompt.promptText, timestamp: Date.now() });
      return prompt.promptText;
    }
    
    // Supabase에서 찾지 못하면 기본값 사용
    console.warn(`❌ 프롬프트를 Supabase에서 찾지 못함: ${category}/${subCategory}/${key}, 기본값 사용`);
    const defaultText = getDefaultPromptByKey(category, subCategory, key);
    // 기본값도 캐시에 저장
    promptCache.set(cacheKey, { text: defaultText, timestamp: Date.now() });
    return defaultText;
  } catch (error) {
    console.error(`❌ Supabase 프롬프트 조회 실패: ${category}/${subCategory}/${key}`, error);
    const defaultText = getDefaultPromptByKey(category, subCategory, key);
    // 기본값도 캐시에 저장
    promptCache.set(cacheKey, { text: defaultText, timestamp: Date.now() });
    return defaultText;
  }
}

// 캐시 업데이트 함수 (프롬프트 수정 시 사용)
export function updatePromptCache(category: string, subCategory: string, key: string, text: string) {
  const cacheKey = `${category}/${subCategory}/${key}`;
  promptCache.set(cacheKey, { text, timestamp: Date.now() });
}

// 프롬프트 캐시 삭제 함수
export function clearPromptCache(category: string, subCategory: string, key: string) {
  const cacheKey = `${category}/${subCategory}/${key}`;
  promptCache.delete(cacheKey);
}

// 지문 길이에 대한 기본 프롬프트를 반환하는 함수
function getDefaultLengthPrompt(length: string): string {
  // 새로운 2개 지문 형식 프롬프트로 변환
  switch (length) {
    case '2개의 지문 생성. 지문당 300자 내외 - 총 600자':
    case '4-5문장으로 구성한 5-6개 단락': // 구 버전 키에 대한 매핑
      return '2개의 지문 생성. 지문당 300자 내외 - 총 600자: 초등학교 중학년(3-4학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 300자 내외로 작성하여 총 600자 정도가 되도록 하세요. 쉬운 어휘와 간단한 문장 구조를 사용하세요.';
    
    case '2개의 지문 생성. 지문당 400자 내외 - 총 800자':
      return '2개의 지문 생성. 지문당 400자 내외 - 총 800자: 초등학교 고학년(5-6학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 400자 내외로 작성하여 총 800자 정도가 되도록 하세요. 다소 복잡한 문장과 전문용어를 적절히 사용할 수 있습니다.';
    
    case '2개의 지문 생성. 지문당 500자 내외 - 총 1,000자':
      return '2개의 지문 생성. 지문당 500자 내외 - 총 1,000자: 중학생(1-3학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 500자 내외로 작성하여 총 1,000자 정도가 되도록 하세요. 논리적 구조와 깊이 있는 내용을 포함할 수 있습니다.';
    
    default:
      // 기본값으로 300자 초등 중학년용 프롬프트 반환
      return '2개의 지문 생성. 지문당 300자 내외 - 총 600자: 초등학교 중학년(3-4학년) 수준에 맞는 지문을 생성하세요. 각 지문은 독립적인 내용으로 구성하되, 동일한 주제의 다른 측면을 다루도록 하세요. 각 지문은 약 300자 내외로 작성하여 총 600자 정도가 되도록 하세요. 쉬운 어휘와 간단한 문장 구조를 사용하세요.';
  }
}

// 기본값에서 프롬프트를 찾는 헬퍼 함수
function getDefaultPromptByKey(category: string, subCategory: string, key: string): string {
  // 기존 하드코딩된 객체들에서 찾기
  switch (subCategory) {
    case 'system':
      // 전체 시스템 프롬프트들을 반환
      if (category === 'passage' && key === 'fullSystemPrompt') {
        return getDefaultPrompts().find(p => p.promptId === 'passage_system_full')?.promptText || '';
      } else if (category === 'vocabulary' && key === 'fullSystemPrompt') {
        return getDefaultPrompts().find(p => p.promptId === 'vocabulary_system_full')?.promptText || '';
      } else if (category === 'comprehensive' && key === 'fullSystemPrompt') {
        return getDefaultPrompts().find(p => p.promptId === 'comprehensive_system_full')?.promptText || '';
      }
      return '';
    case 'division':
    case 'divisionLevel':
      return divisionPrompts[key as keyof typeof divisionPrompts] || '';
    case 'area':
    case 'areaContent':
      return areaPrompts[key as keyof typeof areaPrompts] || '';
    case 'length':
      return outputFormats[key as keyof typeof outputFormats] || '';
    case 'lengthGuideline':
      return lengthPrompts[key as keyof typeof lengthPrompts] || '';
    case 'textType':
      return textTypePrompts[key as keyof typeof textTypePrompts] || '';
    case 'questionGrade':
      return questionGradePrompts[key as keyof typeof questionGradePrompts] || '';
    case 'questionType':
      return questionTypePrompts[key as keyof typeof questionTypePrompts] || '';
    case 'outputFormat':
      if (category === 'vocabulary') {
        return questionOutputFormats[key as keyof typeof questionOutputFormats] || '';
      } else if (category === 'comprehensive') {
        return comprehensiveOutputFormats[key as keyof typeof comprehensiveOutputFormats] || '';
      }
      return '';
    case 'comprehensiveType':
      return comprehensiveQuestionPrompts[key as keyof typeof comprehensiveQuestionPrompts] || '';
    case 'subjectContent':
      // promptsV2에서 과목 프롬프트 찾기
      if (key === '과학' || key === 'science') {
        return getDefaultPrompts().find(p => p.promptId === 'subject-science')?.promptText || '과학';
      } else if (key === '사회' || key === 'social') {
        return getDefaultPrompts().find(p => p.promptId === 'subject-social')?.promptText || '사회';
      }
      return key;
    default:
      // promptsV2에서 직접 찾아보기
      const prompt = getDefaultPrompts().find(p => 
        p.category === category && 
        p.subCategory === subCategory && 
        p.key === key
      );
      return prompt?.promptText || '';
  }
}

// 새로운 동적 프롬프트 생성 함수들 (DB 조회 사용)
export async function generatePassagePromptFromDB(
  division: DivisionType,
  length: PassageLengthType,
  subject: SubjectType,
  grade: GradeType,
  area: AreaType,
  maintopic: string,
  subtopic: string,
  keyword: string,
  textType?: TextType
): Promise<string> {
  try {
    // DB에서 각 프롬프트 조회
    console.log('🔍 Starting prompt DB queries...');
    
    // 전체 시스템 프롬프트 조회 - 실제 DB 키 사용
    let systemPrompt = await getPromptFromDB('passage', 'system', 'system_base');
    console.log(`🔧 System prompt: ${systemPrompt ? 'FROM DB (' + systemPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    const divisionPrompt = await getPromptFromDB('division', getDivisionSubCategory(division), getDivisionKey(division));
    console.log(`📊 Division prompt: ${divisionPrompt ? 'FROM DB (' + divisionPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    const lengthGuidelinePrompt = await getPromptFromDB('passage', 'lengthGuideline', length);
    console.log(`📏 Length prompt: ${lengthGuidelinePrompt ? 'FROM DB (' + lengthGuidelinePrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    const outputFormatPrompt = await getPromptFromDB('passage', 'type', 'json');
    console.log(`📋 Output format prompt: ${outputFormatPrompt ? 'FROM DB (' + outputFormatPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    const areaPrompt = await getPromptFromDB('area', getAreaSubCategory(area), getAreaKey(area));
    console.log(`🧬 Area prompt: ${areaPrompt ? 'FROM DB (' + areaPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    const subjectPrompt = await getPromptFromDB('subject', getSubjectSubCategory(subject), getSubjectKey(subject));
    console.log(`📚 Subject prompt: ${subjectPrompt ? 'FROM DB (' + subjectPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'}`);
    
    console.log('✅ All prompt DB queries completed');
    
    // 시스템 프롬프트가 DB에서 가져와진 경우 템플릿 변수 치환
    let prompt;
    if (systemPrompt) {
      console.log('🔧 Using server system prompt with template substitution');
      // 글의 유형 프롬프트 준비
      let textTypePromptText = '';
      if (textType) {
        console.log(`🔍 Text type lookup: passage/textType/${getTextTypeKey(textType)}`);
        const textTypePrompt = await getPromptFromDB('passage', 'textType', getTextTypeKey(textType));
        console.log(`📄 Text type prompt found: ${textTypePrompt ? 'YES (' + textTypePrompt.length + ' chars)' : 'NO - using default'}`);
        
        if (textTypePrompt) {
          textTypePromptText = textTypePrompt;
        } else {
          console.log(`⚠️ No server prompt for text type '${textType}', using hardcoded fallback`);
          textTypePromptText = getDefaultTextTypePrompt(textType);
        }
      }
      
      // 템플릿 변수 치환
      prompt = systemPrompt
        .replace('{division_prompt}', divisionPrompt || '구분 정보가 없습니다.')
        .replace('{length_prompt}', lengthGuidelinePrompt || getDefaultLengthPrompt(length))
        .replace('{subject}', subjectPrompt || subject)
        .replace('{grade}', grade)
        .replace('{area_prompt}', areaPrompt || area)
        .replace('{area}', area)
        .replace('{maintopic}', maintopic)
        .replace('{subtopic}', subtopic)
        .replace('{keyword}', keyword)
        .replace('{text_type_prompt}', textTypePromptText)
        .replace('{output_format}', outputFormatPrompt || `다음 JSON 형식으로만 출력하십시오:
{
  "passages": [
    {
      "title": "질문형·호기심 유발형 제목",
      "paragraphs": ["단락1 내용", "단락2 내용", "..."],
      "footnote": ["용어1: 설명1 (예시: 예시문장1)", "용어2: 설명2 (예시: 예시문장2)", "..."]
    }
  ]
}`);
      
      console.log('✅ Template substitution completed');
    } else {
      console.log('🔧 Using fallback hardcoded system prompt');
      // 기존 하드코딩된 프롬프트 사용 (폴백)
      prompt = `###지시사항
다음 입력값을 받아 학습 지문(passage)을 생성하십시오. 출력은 하나의 영역으로 구분합니다.
- passage: 입력 조건을 반영해 생성한 지문

모든 지문은 질문형·호기심 유발형 제목을 사용하고, 실생활 예시를 활용해 추상 개념을 설명해야 하며, 임의(random) 로직은 사용하지 않습니다.

###작성절차
1. 키워드 도출
- 구분·과목·학년·영역·지문 길이를 파싱하여 ① 핵심 개념(기초→심화), ② 생활 연계 예시, ③ 학년별 어휘 수준을 도출합니다.
2. 지문(passages) 생성
- 도출한 가이드를 조합해 제목 1개와 본문을 작성합니다.
- 본문은 입력된 지문 길이 가이드라인과 출력 형식 규칙을 정확히 준수합니다.
- **용어 설명 필수 요구사항**: 지문에 등장하는 모든 학습 관련 용어들을 footnote에 포함시켜야 합니다. 최소 20개 이상의 용어를 추출하여 설명하세요.
  * 핵심 개념어와 관련 용어들
  * 지문에 직접 언급된 전문 용어들
  * 학년 수준에 맞는 중요한 어휘들
  * 관련 배경 지식이 필요한 용어들
  * 생활 속에서 사용되는 관련 용어들도 포함
- **용어 설명 형식**: 각 용어에 대해 "용어: 설명 (예시: 예시문장)" 형태로 작성하세요.
  * 설명: 학년 수준에 맞는 간단하고 명확한 설명
  * 예시문장: 해당 용어가 실제로 사용되는 자연스러운 문장
3. 흥미 요소 적용
- 도입부에 실생활 상황·질문을 배치하여 독자의 호기심을 자극합니다.
- 단순 설명문뿐 아니라 비교·예측·원인결과 등 다양한 서술 방식을 활용합니다.
4. 출력 생성
- 아래 [공통 출력 스키마] 형식을 준수한 JSON만 출력하십시오.
- 지정된 키가 없거나 데이터를 찾을 수 없으면 **"-"**로 표기합니다.
- **footnote는 반드시 20개 이상의 용어 설명을 포함해야 하며, 각 용어는 설명과 예시문장을 모두 포함해야 합니다.**

###구분
${divisionPrompt || '구분 정보가 없습니다.'}

###지문 길이
${lengthGuidelinePrompt || getDefaultLengthPrompt(length)}

###과목
${subjectPrompt || subject}

###학년
${grade}

###영역
${areaPrompt || area}

###대주제
${maintopic}
위 대주제를 중심으로 ${area} 영역의 학습 내용과 연결하여 지문을 구성하세요.

###소주제
${subtopic}
이 소주제를 구체적으로 다루며, 대주제와의 연관성을 명확히 하여 지문을 작성하세요.

###핵심 개념어
${keyword}
이 핵심 개념어들을 지문에 자연스럽게 포함시키고, 학년 수준에 맞게 설명하세요. footnote에는 이 용어들을 포함하여 최소 20개 이상의 관련 용어 해설을 추가하세요.`;
    }

    // 시스템 프롬프트가 없는 경우 (폴백)에만 텍스트 타입과 출력 형식 추가
    if (!systemPrompt) {
      if (textType) {
        console.log(`🔍 Text type lookup (fallback): passage/textType/${getTextTypeKey(textType)}`);
        const textTypePrompt = await getPromptFromDB('passage', 'textType', getTextTypeKey(textType));
        console.log(`📄 Text type prompt found: ${textTypePrompt ? 'YES (' + textTypePrompt.length + ' chars)' : 'NO - using default'}`);
        
        if (textTypePrompt) {
          prompt += `

###글의 유형
${textTypePrompt}`;
        } else {
          console.log(`⚠️ No server prompt for text type '${textType}', using hardcoded fallback`);
          const defaultTextTypePrompt = getDefaultTextTypePrompt(textType);
          if (defaultTextTypePrompt) {
            prompt += `

###글의 유형
${defaultTextTypePrompt}`;
          }
        }
      }

      prompt += `

###출력형식(JSON)
${outputFormatPrompt || `다음 JSON 형식으로만 출력하십시오:
{
  "passages": [
    {
      "title": "질문형·호기심 유발형 제목",
      "paragraphs": ["단락1 내용", "단락2 내용", "..."],
      "footnote": ["용어1: 설명1 (예시: 예시문장1)", "용어2: 설명2 (예시: 예시문장2)", "..."]
    }
  ]
}`}`;
    }

    return prompt;
  } catch (error) {
    console.error('DB 프롬프트 생성 실패, 기본 함수 사용:', error);
    // 실패 시 기존 함수 사용
    return generatePassagePrompt(division, length, subject, grade, area, maintopic, subtopic, keyword, textType);
  }
}

export async function generateQuestionPromptFromDB(
  division: DivisionType,
  passage: string,
  questionType: QuestionType
): Promise<string> {
  try {
    const divisionPrompt = await getPromptFromDB('division', getDivisionSubCategory(division), getDivisionKey(division));
    const questionTypePrompt = await getPromptFromDB('vocabulary', 'questionType', questionType);
    const outputFormatPrompt = await getPromptFromDB('vocabulary', 'outputFormat', questionType);

    return `###지시사항
다음 입력값을 기반으로, 해당 지문 내용을 반영한 **문제 3개**를 생성하십시오.
- 일반 문제 1개와 보완 문제 2개를 생성합니다.
- 일반 문제는 학생이 처음 접하는 문제이며, 보완 문제는 오답 시 학습 강화를 위해 생성하는 구조입니다.
- 구분에 맞는 어휘 수준과 사고 수준을 반영해 난이도를 조절해야 합니다.
- 문제는 반드시 지문 내용 또는 개념을 기반으로 출제되어야 하며, 임의(random) 구성은 금지됩니다.

###지문
${passage}

###구분
${divisionPrompt}

###문제유형
${questionTypePrompt}

###출력형식(JSON)
${outputFormatPrompt}`;
  } catch (error) {
    console.error('DB 문제 프롬프트 생성 실패, 기본 함수 사용:', error);
    return generateQuestionPrompt(division, passage, questionType);
  }
}

export async function generateVocabularyPromptFromDB(
  termName: string,
  termDescription: string,
  passage: string,
  division: string,
  questionType?: string
): Promise<string> {
  try {
    // 전체 시스템 프롬프트: system_prompts_v3 테이블의 vocabulary-system-base
    const basePrompt = await getPromptFromDB('vocabulary', 'vocabularySystem', 'system_base');
    const divisionPrompt = await getPromptFromDB('division', getDivisionSubCategory(division), getDivisionKey(division));
    
    // 문제 유형별 프롬프트 가져오기 (새로운 기능)
    const typePrompt = questionType 
      ? await getPromptFromDB('vocabulary', 'vocabularyType', questionType)
      : null;

    console.log('🔧 Vocabulary prompt generation:', {
      basePrompt: basePrompt ? 'FROM DB (' + basePrompt.length + ' chars)' : 'FALLBACK TO HARDCODED',
      divisionPrompt: divisionPrompt ? 'FROM DB (' + divisionPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED',
      typePrompt: typePrompt ? 'FROM DB (' + typePrompt.length + ' chars)' : questionType ? 'TYPE NOT FOUND IN DB' : 'NO TYPE SPECIFIED'
    });

    // DB에서 가져온 프롬프트들을 조합하여 최종 프롬프트 생성
    let finalPrompt = '';
    
    if (basePrompt) {
      // 우선순위: 업데이트된 시스템 프롬프트 사용 (6가지 문제 유형 지원)
      finalPrompt = basePrompt
        .replace(/{termName}/g, termName)
        .replace(/{termDescription}/g, termDescription || '지문에서 추출된 용어')
        .replace(/{passage}/g, passage)
        .replace(/{divisionPrompt}/g, divisionPrompt || division)
        .replace(/{questionTypePrompt}/g, typePrompt || `${questionType} 유형의 문제를 생성해주세요.`);
    } else if (typePrompt) {
      // 폴백: 유형별 프롬프트 사용
      finalPrompt = `${typePrompt}

### 용어 정보
- 용어명: ${termName}
- 용어 설명: ${termDescription || '지문에서 추출된 용어'}

### 지문 내용
${passage}

### 학년 수준
${divisionPrompt || division}

위 정보를 바탕으로 JSON 형식으로 문제를 생성해주세요.`;
    } else {
      // 완전한 폴백
      return generateVocabularyPrompt(termName, termDescription, passage, division);
    }

    return finalPrompt;
  } catch (error) {
    console.error('DB 어휘 프롬프트 생성 실패, 기본 함수 사용:', error);
    return generateVocabularyPrompt(termName, termDescription, passage, division);
  }
}

export async function generateComprehensivePromptFromDB(
  questionType: string,
  passage: string,
  division: string,
  questionCount: number = 3
): Promise<string> {
  try {
    // 서버에서 전체 시스템 프롬프트, 문제 유형별 프롬프트, 구분 프롬프트 조회
    // 출력 형식은 typePrompt에 이미 포함되어 있음
    const systemPrompt = await getPromptFromDB('comprehensive', 'comprehensiveSystem', 'system_base');
    const typePrompt = await getPromptFromDB('comprehensive', 'comprehensiveType', getComprehensiveTypeKey(questionType));
    const divisionPrompt = await getPromptFromDB('division', getDivisionSubCategory(division), getDivisionKey(division));
    
    console.log('Comprehensive prompt generation:', {
      questionType,
      systemPrompt: systemPrompt ? 'FROM DB (' + systemPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED',
      typePrompt: typePrompt ? 'FROM DB (' + typePrompt.length + ' chars)' : 'FALLBACK TO HARDCODED',
      divisionPrompt: divisionPrompt ? 'FROM DB (' + divisionPrompt.length + ' chars)' : 'FALLBACK TO HARDCODED'
    });

    // 서버 시스템 프롬프트가 있으면 템플릿 변수 치환 사용
    if (systemPrompt) {
      console.log('🔧 Using server comprehensive system prompt with template substitution');
      
      const finalPrompt = systemPrompt
        .replace('{questionType}', questionType)
        .replace('{questionCount}', questionCount.toString())
        .replace('{passage}', passage)
        .replace('{divisionPrompt}', divisionPrompt || '난이도 정보가 없습니다.')
        .replace('{typePrompt}', typePrompt || '문제 유형 가이드라인이 없습니다.');
      
      console.log('✅ Comprehensive template substitution completed');
      return finalPrompt;
    }

    // 폴백: 하드코딩된 프롬프트 사용
    console.log('🔧 Using fallback hardcoded comprehensive system prompt');
    return `###지시사항
주어진 지문을 바탕으로 **${questionType}** 유형의 문제 ${questionCount}개를 생성하십시오.
- 지문의 전체적인 이해와 핵심 내용 파악을 평가하는 문제를 생성합니다.
- 각 문제는 서로 다른 관점이나 내용을 다뤄야 합니다.
- 지문에 직접 언급된 내용이나 논리적으로 추론 가능한 내용만을 바탕으로 출제합니다.

###지문
${passage}

###구분 (난이도 조절)  
${divisionPrompt || '난이도 정보가 없습니다.'}

###문제 유형 가이드라인
${typePrompt || '문제 유형 가이드라인이 없습니다.'}

###출력형식(JSON)
${outputPrompt || '출력 형식이 없습니다.'}

###주의사항
- 반드시 위의 JSON 형식을 정확히 준수하십시오.
- 정확히 ${questionCount}개의 문제를 생성하십시오.
- 각 문제는 서로 다른 내용이나 관점을 다뤄야 합니다.
- 정답과 해설은 지문에 명확히 근거해야 합니다.
- 객관식 문제의 오답 선택지도 그럴듯하게 구성하십시오.`;
  } catch (error) {
    console.error('DB 종합 프롬프트 생성 실패, 기본 함수 사용:', error);
    return generateComprehensivePrompt(questionType, passage, division, questionCount);
  }
}

// ============================================================================
// 특정 프롬프트 ID로 기본 프롬프트 가져오기
// ============================================================================
export function getDefaultPromptById(promptId: string): string | null {
  console.log('getDefaultPromptById called with:', promptId);
  const defaultPrompts = getDefaultPrompts();
  const prompt = defaultPrompts.find(p => p.promptId === promptId);
  console.log('Found prompt:', prompt);
  return prompt ? prompt.promptText : null;
}